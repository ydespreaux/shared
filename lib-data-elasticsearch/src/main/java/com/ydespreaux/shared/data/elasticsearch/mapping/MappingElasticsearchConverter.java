package com.ydespreaux.shared.data.elasticsearch.mapping;import com.ydespreaux.shared.data.elasticsearch.annotations.Document;import io.searchbox.annotations.JestId;import io.searchbox.annotations.JestVersion;import lombok.Getter;import lombok.extern.slf4j.Slf4j;import org.elasticsearch.ElasticsearchException;import org.springframework.core.env.Environment;import org.springframework.util.StringUtils;import java.lang.reflect.Field;import java.util.Date;import java.util.Map;import java.util.Optional;import java.util.concurrent.ConcurrentHashMap;import java.util.regex.Matcher;import java.util.regex.Pattern;@Slf4jpublic class MappingElasticsearchConverter implements ElasticsearchConverter {    private final Map<Class<?>, ElasticsearchPersistentEntity<?>> context = new ConcurrentHashMap<>();    private final ElasticsearchPersistentEntityFactory factory;    private final Environment environment;    public MappingElasticsearchConverter(Environment environment) {        this.factory = new ElasticsearchPersistentEntityFactory();        this.environment = environment;    }    @Override    public <T> ElasticsearchPersistentEntity<T> getRequiredPersistentEntity(Class<T> clazz) {        if (context.containsKey(clazz)) {            return (ElasticsearchPersistentEntity<T>)context.get(clazz);        }        ElasticsearchPersistentEntity<T> entity = this.factory.createPersistentEntity(this.environment, clazz);        this.context.put(clazz, entity);        return entity;    }    public static class ElasticsearchPersistentEntityFactory {        private static final Pattern pattern = Pattern.compile("\\Q${\\E(.+?)\\Q}\\E");        public <T> ElasticsearchPersistentEntity<T> createPersistentEntity(final Environment environment, final Class<T> clazz) {            return new ElasticsearchPersistentEntityImpl(environment, clazz);        }        @Getter        private class ElasticsearchPersistentEntityImpl<T> implements ElasticsearchPersistentEntity<T> {            private Class<T> entityClass;            private String aliasOrIndexName;            private String indexPattern;            private String type;            private IndexTimeBasedSupport<T> indexSupport;            private Field idProperty;            private Field versionProperty;            private Boolean createIndex;            private Boolean indexTimeBased;            private String indexPath;            public ElasticsearchPersistentEntityImpl(Environment environment, Class<T> clazz) {                final Document document = clazz.getAnnotation(Document.class);                this.entityClass = clazz;                this.type = document.type();                this.createIndex = document.createIndex;                this.aliasOrIndexName = getEnvironmentValue(environment, document.aliasOrIndex());                this.indexPattern = getEnvironmentValue(environment, document.indexPattern());                this.indexTimeBased = StringUtils.hasText(this.indexPattern);                this.indexPath = document.indexPath();                try {                    this.indexSupport = document.indexTimeBasedSupport().newInstance();                } catch (Exception e) {                    throw new ElasticsearchException(e);                }                Field[] fields = clazz.getDeclaredFields();                for (Field field : fields) {                    if (field.isAnnotationPresent(JestId.class)) {                        field.setAccessible(true);                        this.idProperty = field;                    } else if (field.isAnnotationPresent(JestVersion.class)) {                        field.setAccessible(true);                        this.versionProperty = field;                    }                }            }            /**             * @param source             * @return             */            @Override            public String getIndex(T source) {                if (isIndexTimeBased()) {                    return this.indexSupport.buildIndex(IndexTimeBasedParameter.of(indexPattern, new Date(), source));                }                return this.aliasOrIndexName;            }            @Override            public void setPersistentEntityId(T entity, String id) {                if (idProperty == null) {                    if (log.isWarnEnabled()) {                        log.warn("No propertyId defined for entity class {}", entityClass);                    }                    return;                }                setPersistentProperty(idProperty, entity, id);            }            /**             * @param entity             * @param version             */            @Override            public void setPersistentEntityVersion(T entity, Integer version) {                setPersistentProperty(versionProperty, entity, version);            }            /**             * @param entity             * @return             */            @Override            public Optional<String> getPersistentEntityId(T entity) {                if (this.idProperty == null){                    if (log.isWarnEnabled()) {                        log.warn("No propertyId defined for entity class {}", entityClass);                    }                    return Optional.empty();                }                try {                    Object id = this.idProperty.get(entity);                    return id == null ? Optional.empty() : Optional.of(id.toString());                } catch (IllegalAccessException e) {                    if (log.isWarnEnabled()) {                        log.warn("getPersistentEntityId {} failed", e);                    }                    return Optional.empty();                }            }            /**             * @return             */            @Override            public Boolean createIndex() {                return this.createIndex;            }            /**             * @return             */            @Override            public Boolean isIndexTimeBased() {                return this.indexTimeBased;            }            /**             * @return             */            @Override            public String getIndexPath() {                return this.indexPath;            }            private void setPersistentProperty(Field field, T entity, Object value) {                if (field == null) {                    return;                }                try {                    field.set(entity, value);                } catch (IllegalAccessException e) {                    if (log.isWarnEnabled()) {                        log.warn(String.format("setPersistentProperty %s failed",field.getName()), e);                    }                }            }            private String getEnvironmentValue(Environment environment, String expression) {                String value = null;                // Create the matcher                Matcher matcher = pattern.matcher(expression);                // If the matching is there, then add it to the map and return the value                if (matcher.find()) {                    value = environment.getProperty(matcher.group(1));                }                return value == null ? expression : value;            }        }    }}