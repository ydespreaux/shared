package com.ydespreaux.shared.data.elasticsearch.core;import com.ydespreaux.shared.data.elasticsearch.ScrolledPage;import com.ydespreaux.shared.data.elasticsearch.annotations.Document;import com.ydespreaux.shared.data.elasticsearch.core.converter.ElasticsearchConverter;import com.ydespreaux.shared.data.elasticsearch.core.mapping.ElasticsearchPersistentEntity;import com.ydespreaux.shared.data.elasticsearch.core.query.*;import com.ydespreaux.shared.data.elasticsearch.core.scroll.ScrolledPageResult;import com.ydespreaux.shared.data.elasticsearch.indices.IndexBuilder;import lombok.extern.slf4j.Slf4j;import org.apache.commons.io.FilenameUtils;import org.elasticsearch.ElasticsearchException;import org.elasticsearch.ElasticsearchStatusException;import org.elasticsearch.action.admin.indices.alias.get.GetAliasesRequest;import org.elasticsearch.action.admin.indices.delete.DeleteIndexRequest;import org.elasticsearch.action.admin.indices.get.GetIndexRequest;import org.elasticsearch.action.admin.indices.template.get.GetIndexTemplatesRequest;import org.elasticsearch.action.admin.indices.template.get.GetIndexTemplatesResponse;import org.elasticsearch.action.bulk.BulkItemResponse;import org.elasticsearch.action.bulk.BulkRequest;import org.elasticsearch.action.bulk.BulkResponse;import org.elasticsearch.action.delete.DeleteRequest;import org.elasticsearch.action.get.GetRequest;import org.elasticsearch.action.get.GetResponse;import org.elasticsearch.action.index.IndexRequest;import org.elasticsearch.action.index.IndexResponse;import org.elasticsearch.action.search.*;import org.elasticsearch.client.*;import org.elasticsearch.cluster.metadata.AliasMetaData;import org.elasticsearch.common.Nullable;import org.elasticsearch.common.Strings;import org.elasticsearch.common.unit.TimeValue;import org.elasticsearch.index.query.QueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.rest.RestStatus;import org.elasticsearch.search.aggregations.AbstractAggregationBuilder;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;import org.elasticsearch.search.sort.FieldSortBuilder;import org.elasticsearch.search.sort.SortBuilder;import org.elasticsearch.search.sort.SortBuilders;import org.elasticsearch.search.sort.SortOrder;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.core.io.Resource;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Sort;import org.springframework.util.Assert;import org.springframework.util.StringUtils;import java.io.IOException;import java.util.*;import static org.elasticsearch.client.Requests.refreshRequest;import static org.elasticsearch.index.VersionType.EXTERNAL;import static org.springframework.util.CollectionUtils.isEmpty;/** * Class define the Jest Elastic Search operations. */@Slf4jpublic class ElasticsearchTemplate implements ElasticsearchOperations, ApplicationContextAware {    /**     * jest client property.     */    private final RestHighLevelClient client;    /**     * {@link ElasticsearchConverter} property.     */    private final ElasticsearchConverter elasticsearchConverter;    /**     *     */    private final ResultsMapper resultsMapper;    /**     * The used {@link ApplicationContext}     */    private ApplicationContext applicationContext;    /**     * Construct an instance with the given client and elasticsearchConverter parameters.     *     * @param client                 the given client.     * @param elasticsearchConverter the given elasticsearchConverter.     */    public ElasticsearchTemplate(final RestHighLevelClient client,                                 final ElasticsearchConverter elasticsearchConverter,                                 final ResultsMapper resultsMapper) {        this.client = client;        this.elasticsearchConverter = elasticsearchConverter;        this.resultsMapper = resultsMapper;    }    /**     *     * @return     */    @Override    public ElasticsearchConverter getElasticsearchConverter() {        return this.elasticsearchConverter;    }    /**     *     * @param request     * @return     */    @Override    public Response performRequest(Request request) throws IOException {        return client.getLowLevelClient().performRequest(request);    }    /**     *     * @param request     * @param listener     */    @Override    public void performRequestAsync(Request request, ResponseListener listener) {        client.getLowLevelClient().performRequestAsync(request, listener);    }    /**     * @see ElasticsearchOperations#getPersistentEntityFor(Class)  method     */    @Override    public <T> ElasticsearchPersistentEntity<T> getPersistentEntityFor(Class<T> clazz) {        Assert.isTrue(clazz.isAnnotationPresent(Document.class), "Unable to identify template. " + clazz.getSimpleName()                + " is not a TimeBasedDocument. Make sure the document class is annotated with @TimeBasedDocument");        return elasticsearchConverter.getRequiredPersistentEntity(clazz);    }    /**     * @see ApplicationContextAware#setApplicationContext(ApplicationContext)  method     */    @Override    public void setApplicationContext(ApplicationContext applicationContext) {        this.applicationContext = applicationContext;        if (elasticsearchConverter instanceof ApplicationContextAware) {            ((ApplicationContextAware) elasticsearchConverter).setApplicationContext(applicationContext);        }    }    /**     * @see ElasticsearchOperations#createTemplate(String, String, Boolean)  method     */    @Override    public void createTemplate(String templateName, String location, Boolean createOnly) {        Resource resource = applicationContext.getResource(location);        if (!resource.exists()) {            throw new ElasticsearchException("File {} not found", location);        }        createTemplate(templateName, Collections.singletonList(resource), createOnly);    }    /**     * @see ElasticsearchOperations#createTemplate(String, String, Boolean)  method     */    @Override    public void createTemplate(String templateName, List<Resource> locations, Boolean createOnly) {        if (createOnly && templateExists(templateName)) {            return;        }        Request request = new Request("PUT", "_template/" + templateName);        try {            String jsonTemplate = Strings.toString(new IndexBuilder().buildTemplate(locations));            request.setJsonEntity(jsonTemplate);            this.performRequest(request);            if (log.isInfoEnabled()) {                log.info("New template {} added : {}", templateName, jsonTemplate);            }        } catch (IOException e) {            throw new ElasticsearchException("Error for request: " + request.toString(), e);        }    }    /**     * @see ElasticsearchOperations#templateExists(String)  method     */    @Override    public boolean templateExists(String templateName) {        GetIndexTemplatesRequest request = new GetIndexTemplatesRequest(templateName);        try {            GetIndexTemplatesResponse response = this.client.indices().getTemplate(request, RequestOptions.DEFAULT);            return !response.getIndexTemplates().isEmpty();        } catch (ElasticsearchStatusException e) {            if (e.status() == RestStatus.NOT_FOUND) {                return false;            }            throw new ElasticsearchException("Error for Get template request: " + request.toString(), e);        } catch (IOException e) {            throw new ElasticsearchException("Error for Get template request: " + request.toString(), e);        }    }    /**     * @see ElasticsearchOperations#deleteTemplate(String)  method     */    @Override    public void deleteTemplate(String templateName) {        if (templateExists(templateName)) {            Request request = new Request("DELETE", "_template/" + templateName);            try {                this.performRequest(request);                if (log.isInfoEnabled()) {                    log.info("Deleted template {}", templateName);                }            } catch (IOException e) {                throw new ElasticsearchException("Error for delete template request: " + request.toString(), e);            }        }    }    /**     * @see ElasticsearchOperations#deleteIndexByName(String)   method     */    @Override    public boolean deleteIndexByName(String indexName) {        Objects.requireNonNull(indexName);        DeleteIndexRequest request = new DeleteIndexRequest(indexName);        try {            boolean deleted = this.client.indices().delete(request, RequestOptions.DEFAULT).isAcknowledged();            if (log.isInfoEnabled() && deleted) {                log.info("Deleted index {}", indexName);            }            return deleted;        } catch( ElasticsearchStatusException e){            if (e.status() == RestStatus.NOT_FOUND) {                return false;            }            throw new ElasticsearchException("Error for delete index request: " + request.toString(), e);        } catch (IOException e) {            throw new ElasticsearchException("Error for delete index request: " + request.toString(), e);        }    }    /**     * @see ElasticsearchOperations#deleteIndexByAlias(String)    method     */    @Override    public void deleteIndexByAlias(String aliasName) {        Objects.requireNonNull(aliasName);        GetAliasesRequest request = new GetAliasesRequest(aliasName);        try {            Map<String, Set<AliasMetaData>> indices = this.client.indices().getAlias(request, RequestOptions.DEFAULT).getAliases();            indices.keySet().forEach(this::deleteIndexByName);        } catch (IOException e) {            throw new ElasticsearchException("Error for get aliases request: " + request.toString(), e);        }    }    /**     * Check if Index Exist     *     * @param indexName     * @return true if index exist     */    @Override    public boolean indexExists(String indexName) {        Objects.requireNonNull(indexName);        GetIndexRequest request = new GetIndexRequest();        request.indices(indexName);        try {            return client.indices().exists(request, RequestOptions.DEFAULT);        } catch (IOException e) {            throw new ElasticsearchException("Error while for indexExists request: " + request.toString(), e);        }    }    @Override    public boolean createIndex(String indexName) {        Assert.notNull(indexName, "No index defined for Query");        try {            return client.indices().create(Requests.createIndexRequest(indexName), RequestOptions.DEFAULT).isAcknowledged();        } catch (Exception e) {            throw new ElasticsearchException("Failed to create index " + indexName, e);        }    }    /**     * @param indexName     * @param indexPath     * @return     */    @Override    public boolean createIndexWithSettingsAndMapping(String indexName, String indexPath) {        final String[] profiles = this.applicationContext.getEnvironment().getActiveProfiles();        List<Resource> locations = new ArrayList<>(profiles.length + 1);        Resource resource = this.applicationContext.getResource(indexPath);        if (resource.exists()) {            locations.add(resource);        } else if (log.isWarnEnabled()) {            log.warn("Resource {} not found", indexPath);        }        String extension = FilenameUtils.getExtension(indexPath);        boolean hasExtension = StringUtils.hasLength(extension);        String prefix = indexPath.substring(0, indexPath.length() - (hasExtension ? extension.length() + 1 : 0));        for (String profile : profiles) {            String profilPath = prefix + "-" + profile + (hasExtension ? "." + extension : "");            Resource profilResource = this.applicationContext.getResource(profilPath);            if (profilResource.exists()) {                locations.add(profilResource);            }        }        Request request = new Request("PUT", indexName);        try {            String jsonIndex = Strings.toString(new IndexBuilder().buildTemplate(locations));            request.setJsonEntity(jsonIndex);            this.client.getLowLevelClient().performRequest(request);            return true;        }catch(IOException e) {            throw new ElasticsearchException("Failed to create index request: " + request.toString(), e);        }    }    /**     * @see ElasticsearchOperations#index(Object, Class)     method     */    @Override    public <T> T index(T entity, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        IndexRequest request = createIndexRequest(entity, clazz);        try {            IndexResponse response = client.index(request, RequestOptions.DEFAULT);            persistentEntity.setPersistentEntityId(entity, response.getId());            persistentEntity.setPersistentEntityVersion(entity, response.getVersion());            return entity;        } catch (IOException e) {            throw new ElasticsearchException("Error while index for request: " + request.toString(), e);        }    }    /**     * @see ElasticsearchOperations#bulkIndex(List, Class) method     */    @Override    public <T> List<T> bulkIndex(List<T> entities, Class<T> clazz) {        if (entities.isEmpty())            return entities;        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        BulkRequest bulkRequest = new BulkRequest();        entities.forEach(entity -> bulkRequest.add(createIndexRequest(entity, clazz)));        try {            BulkResponse response = client.bulk(bulkRequest, RequestOptions.DEFAULT);            checkForBulkUpdateFailure(response);            BulkItemResponse[] items = response.getItems();            for (int i = 0; i < entities.size(); i++) {                persistentEntity.setPersistentEntityId(entities.get(i), items[i].getId());                persistentEntity.setPersistentEntityVersion(entities.get(i), items[i].getVersion());            }            return entities;        } catch (IOException e) {            throw new ElasticsearchException("Error while bulk for request: " + bulkRequest.toString(), e);        }    }    @Override    public List<?> bulkIndex(List<?> entities) {        if (entities.isEmpty())            return entities;        BulkRequest bulkRequest = new BulkRequest();        entities.forEach(entity -> bulkRequest.add(createIndexRequest(entity, entity.getClass())));        try {            BulkResponse response = client.bulk(bulkRequest, RequestOptions.DEFAULT);            checkForBulkUpdateFailure(response);            BulkItemResponse[] items = response.getItems();            for (int i = 0; i < entities.size(); i++) {                Object entity = entities.get(i);                ElasticsearchPersistentEntity persistentEntity = getPersistentEntityFor(entity.getClass());                persistentEntity.setPersistentEntityId(entities.get(i), items[i].getId());                persistentEntity.setPersistentEntityVersion(entities.get(i), items[i].getVersion());            }            return entities;        } catch (IOException e) {            throw new ElasticsearchException("Error while bulk for request: " + bulkRequest.toString(), e);        }    }    /**     *     * @param response     */    private void checkForBulkUpdateFailure(BulkResponse response) {        if (response.hasFailures()) {            Map<String, String> failedDocuments = new HashMap<>();            for (BulkItemResponse item : response.getItems()) {                if (item.isFailed())                    failedDocuments.put(item.getId(), item.getFailureMessage());            }            throw new ElasticsearchException(                    "Bulk indexing has failures. Use ElasticsearchException.getFailedDocuments() for detailed messages ["                            + failedDocuments + "]",                    failedDocuments);        }    }    /**     * @param source     * @return     */    private <T> IndexRequest createIndexRequest(T source, Class<?> clazz) {        Objects.requireNonNull(source);        ElasticsearchPersistentEntity<T> persistentEntity = (ElasticsearchPersistentEntity<T>) getPersistentEntityFor(clazz);        String indexName = persistentEntity.getIndex(source);        String type = persistentEntity.getTypeName();        String id = persistentEntity.getPersistentEntityId(source);        IndexRequest indexRequest = id != null ? new IndexRequest(indexName, type, id) : new IndexRequest(indexName, type);        indexRequest.source(this.resultsMapper.getEntityMapper().mapToString(source), Requests.INDEX_CONTENT_TYPE);        Long version = persistentEntity.getPersistentEntityVersion(source);        if (version != null) {            indexRequest.version(version);            indexRequest.versionType(EXTERNAL);        }        return indexRequest;    }    /**     * @see ElasticsearchOperations#findById(Class, String)  method     */    @Override    public <T> T findById(Class<T> clazz, String documentId) {        Objects.requireNonNull(documentId, "documentId parameter canno't be null !");        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        if (persistentEntity.isIndexTimeBased()) {            SearchQuery query = new NativeSearchQueryBuilder()                    .withQuery(QueryBuilders.termQuery("_id", documentId))                    .withPageable(PageRequest.of(0, 1))                    .build();            SearchResponse response = doSearch(prepareSearch(query, clazz), query);            if (response != null && response.getHits().totalHits > 0) {                return this.resultsMapper.mapEntity(response.getHits().getAt(0), clazz);            }            return null;        }else {            GetRequest request = new GetRequest(persistentEntity.getAliasOrIndexName(), persistentEntity.getTypeName(), documentId);            GetResponse response;            try {                response = client.get(request, RequestOptions.DEFAULT);                T entity = this.resultsMapper.mapResult(response, clazz);                return entity;            } catch( ElasticsearchStatusException e){                if (e.status() == RestStatus.NOT_FOUND) {                    return null;                }                throw new ElasticsearchException("Error for delete index request: " + request.toString(), e);            } catch (IOException e) {                throw new ElasticsearchException("Error while getting for request: " + request.toString(), e);            }        }    }    @Override    public <T> Boolean existsById(Class<T> clazz, String documentId) {        Objects.requireNonNull(documentId, "documentId parameter canno't be null !");        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        FetchSourceFilterBuilder sourceBuilder = new FetchSourceFilterBuilder();        sourceBuilder.withIncludes("id");        SearchQuery query = new NativeSearchQueryBuilder()            .withQuery(QueryBuilders.termQuery("_id", documentId))            .withSourceFilter(sourceBuilder.build())            .withPageable(PageRequest.of(0, 1))            .build();        SearchResponse response = doSearch(prepareSearch(query, clazz), query);        return response != null && response.getHits().totalHits > 0;    }    @Override    public <T> List<T> search(SearchQuery query, Class<T> clazz) {        SearchResponse response = doSearch(prepareSearch(query, clazz), query);        if (response == null) {            return Collections.EMPTY_LIST;        }        return this.resultsMapper.mapEntity(response.getHits(), clazz);    }    /**     *     * @param scrollTimeInMillis     * @param searchQuery             the given query.     * @param clazz               the given {@link Class} clazz.     * @param <T>     * @return     */    @Override    public <T> ScrolledPage<T> startScroll(long scrollTimeInMillis, SearchQuery searchQuery, Class<T> clazz) {        return this.startScroll(scrollTimeInMillis, searchQuery, clazz, this.resultsMapper);    }    /**     *     * @param scrollTimeInMillis     * @param searchQuery     * @param clazz     * @param mapper     * @param <T>     * @return     */    @Override    public <T> ScrolledPage<T> startScroll(long scrollTimeInMillis, SearchQuery searchQuery, Class<T> clazz, SearchResultMapper mapper) {        SearchResponse response = doScroll(prepareScroll(searchQuery, scrollTimeInMillis, clazz), searchQuery);        return mapper.mapResults(response, clazz);    }    /**     *     * @param request     * @param searchQuery     * @return     */    private SearchResponse doScroll(SearchRequest request, SearchQuery searchQuery) {        Assert.notNull(searchQuery.getIndices(), "No index defined for Query");        Assert.notNull(searchQuery.getTypes(), "No type define for Query");        Assert.notNull(searchQuery.getPageable(), "Query.pageable is required for scan & scroll");        if (searchQuery.getQuery() != null) {            request.source().query(searchQuery.getQuery());        }        if (searchQuery.getFilter() != null) {            request.source().postFilter(searchQuery.getFilter());        }        request.source().version(true);        try {            return client.search(request, RequestOptions.DEFAULT);        } catch (IOException e) {            throw new ElasticsearchException("Error for search request with scroll: " + request.toString(), e);        }    }    /**     *     * @param query     * @param scrollTimeInMillis     * @param clazz     * @param <T>     * @return     */    private <T> SearchRequest prepareScroll(Query query, long scrollTimeInMillis, Class<T> clazz) {        setPersistentEntityIndexAndType(query, clazz);        return prepareScroll(query, scrollTimeInMillis);    }    /**     *     * @param query     * @param scrollTimeInMinutes     * @return     */    private SearchRequest prepareScroll(Query query, long scrollTimeInMinutes) {        SearchRequest request = new SearchRequest(toArray(query.getIndices()));        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();        request.types(toArray(query.getTypes()));        request.scroll(TimeValue.timeValueMinutes(scrollTimeInMinutes));        if (query.getPageable().isPaged()) {            searchSourceBuilder.size(query.getPageable().getPageSize());        }        if (query.getSort() != null) {            for (Sort.Order order : query.getSort()) {                FieldSortBuilder sort = SortBuilders.fieldSort(order.getProperty())                        .order(order.getDirection().isDescending() ? SortOrder.DESC : SortOrder.ASC);                if (order.getNullHandling() == Sort.NullHandling.NULLS_FIRST) {                    sort.missing("_first");                } else if (order.getNullHandling() == Sort.NullHandling.NULLS_LAST) {                    sort.missing("_last");                }                searchSourceBuilder.sort(sort);            }        }        if (!isEmpty(query.getFields())) {            searchSourceBuilder.fetchSource(toArray(query.getFields()), null);        }        request.source(searchSourceBuilder);        return request;    }    /**     * @see ElasticsearchOperations#continueScroll(String, long, Class)   method     */    @Override    public <T> ScrolledPage<T> continueScroll(@Nullable String scrollId, long scrollTimeInMinutes, Class<T> clazz) {        return continueScroll(scrollId, scrollTimeInMinutes, clazz, this.resultsMapper);    }    /**     *     * @param scrollId     * @param scrollTimeInMinutes     * @param clazz     * @param mapper     * @param <T>     * @return     */    @Override    public <T> ScrolledPage<T> continueScroll(@Nullable String scrollId, long scrollTimeInMinutes, Class<T> clazz, SearchResultMapper mapper) {        SearchScrollRequest request = new SearchScrollRequest(scrollId);        request.scroll(TimeValue.timeValueMinutes(scrollTimeInMinutes));        SearchResponse response;        try {            response = client.scroll(request, RequestOptions.DEFAULT);        } catch( ElasticsearchStatusException e){            if (e.status() == RestStatus.NOT_FOUND) {                return ScrolledPageResult.of(Collections.EMPTY_LIST, 0L, scrollId);            }            throw new ElasticsearchException("Error for delete index request: " + request.toString(), e);        } catch (IOException e) {            throw new ElasticsearchException("Error for search request with scroll: " + request.toString(), e);        }        return mapper.mapResults(response, clazz);    }    /**     * @see ElasticsearchOperations#clearScroll(String)  method     */    @Override    public void clearScroll(String scrollId) {        ClearScrollRequest request = new ClearScrollRequest();        request.addScrollId(scrollId);        try {            ClearScrollResponse response = client.clearScroll(request, RequestOptions.DEFAULT);        } catch (IOException e) {            throw new ElasticsearchException("Error for search request with scroll: " + request.toString(), e);        }    }    /**     * @see ElasticsearchOperations#deleteAll(Class)  method     */    @Override    public <T> void deleteAll(Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        if (persistentEntity.isIndexTimeBased()) {            GetAliasesRequest request = new GetAliasesRequest(persistentEntity.getAliasOrIndexName());            GetAliasesResponse response = null;            try {                response = this.client.indices().getAlias(request, RequestOptions.DEFAULT);                response.getAliases().keySet().forEach(this::deleteIndexByName);            } catch (IOException e) {                throw new ElasticsearchException("Error for get aliases request: " + request.toString(), e);            }        }else{            deleteByQuery(QueryBuilders.matchAllQuery(), clazz);        }    }    /**     * @see ElasticsearchOperations#deleteAll(List, Class)  method     */    @Override    public <T> void deleteAll(List<T> entities, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        Set<String> ids = new HashSet<>();        entities.forEach(entity -> {            String id = persistentEntity.getPersistentEntityId(entity);            if (id != null) {                ids.add(id);            }        });        if (!ids.isEmpty()) {            deleteByQuery(QueryBuilders.termsQuery("_id", ids), clazz);        }    }    /**     * @see ElasticsearchOperations#delete(Object, Class)   method     */    @Override    public <T> void delete(T entity, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        String id = persistentEntity.getPersistentEntityId(entity);        if (id != null) {            this.deleteById(id, clazz);        }    }    /**     * @see ElasticsearchOperations#deleteById(String, Class)   method     */    @Override    public <T> void deleteById(String documentId, Class<T> clazz) {        Assert.notNull(documentId, "documentId must not be null!");        deleteByQuery(QueryBuilders.termQuery("_id", documentId), clazz);    }    /**     * @param query     */    private <T> void deleteByQuery(QueryBuilder query, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        String indexName = persistentEntity.getAliasOrIndexName();        String typeName = persistentEntity.getTypeName();        Integer pageSize = 1000;        Long scrollTimeInMinutes = 1L;        SearchQuery searchQuery = new NativeSearchQueryBuilder()                .withQuery(query)                .withIndices(indexName)                .withTypes(typeName)                .withPageable(PageRequest.of(0, pageSize))                .build();        ScrolledPage<T> scrolledResult = startScroll(scrollTimeInMinutes, searchQuery, clazz);        BulkRequest request = new BulkRequest();        List<T> entities = new ArrayList<>();        do {            entities.addAll(scrolledResult.getContent());            scrolledResult = continueScroll(scrolledResult.getScrollId(), scrollTimeInMinutes,                    clazz);        } while (scrolledResult.getContent().size() != 0);        for (T entity : entities) {            request.add(new DeleteRequest(persistentEntity.getIndex(entity), typeName, persistentEntity.getPersistentEntityId(entity)));        }        if (request.numberOfActions() > 0) {            BulkResponse response;            try {                response = client.bulk(request, RequestOptions.DEFAULT);                checkForBulkUpdateFailure(response);            } catch (IOException e) {                throw new ElasticsearchException("Error while deleting bulk: " + request.toString(), e);            }        }        clearScroll(scrolledResult.getScrollId());    }    /**     * @see ElasticsearchOperations#refresh(Class)  method     */    @Override    public <T> void refresh(Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        this.refresh(persistentEntity.getAliasOrIndexName());    }    /**     *     * @param indexName     */    @Override    public void refresh(String indexName) {        Assert.notNull(indexName, "No index defined for refresh()");        try {            client.indices().refresh(refreshRequest(indexName), RequestOptions.DEFAULT);        } catch (IOException e) {            throw new ElasticsearchException("failed to refresh index: " + indexName, e);        }    }    /**     *     * @param searchRequest     * @param searchQuery     * @return     */    private SearchResponse doSearch(SearchRequest searchRequest, SearchQuery searchQuery) {        if (searchQuery.getFilter() != null) {            searchRequest.source().postFilter(searchQuery.getFilter());        }        if (!isEmpty(searchQuery.getElasticsearchSorts())) {            for (SortBuilder sort : searchQuery.getElasticsearchSorts()) {                searchRequest.source().sort(sort);            }        }        if (searchQuery.getHighlightFields() != null || searchQuery.getHighlightBuilder() != null) {            HighlightBuilder highlightBuilder = searchQuery.getHighlightBuilder();            if (highlightBuilder == null) {                highlightBuilder = new HighlightBuilder();            }            if(searchQuery.getHighlightFields() != null) {                for (HighlightBuilder.Field highlightField : searchQuery.getHighlightFields()) {                    highlightBuilder.field(highlightField);                }            }            searchRequest.source().highlighter(highlightBuilder);        }        if (!isEmpty(searchQuery.getIndicesBoost())) {            for (IndexBoost indexBoost : searchQuery.getIndicesBoost()) {                searchRequest.source().indexBoost(indexBoost.getIndexName(), indexBoost.getBoost());            }        }        if (!isEmpty(searchQuery.getAggregations())) {            for (AbstractAggregationBuilder aggregationBuilder : searchQuery.getAggregations()) {                searchRequest.source().aggregation(aggregationBuilder);            }        }        try {            return client.search(searchRequest, RequestOptions.DEFAULT);        } catch( ElasticsearchStatusException e){            if (e.status() == RestStatus.NOT_FOUND) {                return null;            }            throw new ElasticsearchException("Error for search request with scroll: " + searchRequest.toString(), e);        } catch (IOException e) {            throw new ElasticsearchException("Error for search request with scroll: " + searchRequest.toString(), e);        }    }    /**     *     * @param query     * @param clazz     * @param <T>     * @return     */    private <T> SearchRequest prepareSearch(Query query, Class<T> clazz) {        setPersistentEntityIndexAndType(query, clazz);        return prepareSearch(query, Optional.empty());    }    /**     *     * @param query     * @param clazz     * @param <T>     * @return     */    private <T> SearchRequest prepareSearch(SearchQuery query, Class<T> clazz) {        setPersistentEntityIndexAndType(query, clazz);        return prepareSearch(query, Optional.ofNullable(query.getQuery()));    }    /**     *     * @param query     * @param builder     * @return     */    private SearchRequest prepareSearch(Query query, Optional<QueryBuilder> builder) {        Assert.notNull(query.getIndices(), "No index defined for Query");        Assert.notNull(query.getTypes(), "No type defined for Query");        int startRecord = 0;        SearchRequest request = new SearchRequest(toArray(query.getIndices()));        SearchSourceBuilder sourceBuilder = new SearchSourceBuilder();        request.types(toArray(query.getTypes()));        sourceBuilder.version(true);        sourceBuilder.trackScores(query.getTrackScores());        if (builder.isPresent()) {            sourceBuilder.query(builder.get());        }        if (query.getSourceFilter() != null) {            SourceFilter sourceFilter = query.getSourceFilter();            sourceBuilder.fetchSource(sourceFilter.getIncludes(), sourceFilter.getExcludes());        }        if (query.getPageable().isPaged()) {            startRecord = query.getPageable().getPageNumber() * query.getPageable().getPageSize();            sourceBuilder.size(query.getPageable().getPageSize());        }        sourceBuilder.from(startRecord);        if (!query.getFields().isEmpty()) {            sourceBuilder.fetchSource(toArray(query.getFields()), null);        }        if (query.getIndicesOptions() != null) {            request.indicesOptions(query.getIndicesOptions());        }        if (query.getSort() != null) {            for (Sort.Order order : query.getSort()) {                FieldSortBuilder sort = SortBuilders.fieldSort(order.getProperty())                        .order(order.getDirection().isDescending() ? SortOrder.DESC : SortOrder.ASC);                if (order.getNullHandling() == Sort.NullHandling.NULLS_FIRST) {                    sort.missing("_first");                } else if (order.getNullHandling() == Sort.NullHandling.NULLS_LAST) {                    sort.missing("_last");                }                sourceBuilder.sort(sort);            }        }        if (query.getMinScore() > 0) {            sourceBuilder.minScore(query.getMinScore());        }        request.source(sourceBuilder);        return request;    }    /**     *     * @param query     * @param clazz     * @param <T>     */    private <T> void setPersistentEntityIndexAndType(Query query, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        if (query.getIndices().isEmpty()) {            query.addIndices(persistentEntity.getAliasOrIndexName());        }        if (query.getTypes().isEmpty()) {            query.addTypes(persistentEntity.getTypeName());        }    }    /**     *     * @param values     * @return     */    private static String[] toArray(List<String> values) {        String[] valuesAsArray = new String[values.size()];        return values.toArray(valuesAsArray);    }}