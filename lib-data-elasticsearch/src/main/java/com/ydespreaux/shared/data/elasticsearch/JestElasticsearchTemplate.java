package com.ydespreaux.shared.data.elasticsearch;import com.ydespreaux.shared.data.elasticsearch.annotations.Document;import com.ydespreaux.shared.data.elasticsearch.indices.IndexBuilder;import com.ydespreaux.shared.data.elasticsearch.indices.aliases.GetAlias;import com.ydespreaux.shared.data.elasticsearch.mapping.ElasticsearchConverter;import com.ydespreaux.shared.data.elasticsearch.mapping.ElasticsearchPersistentEntity;import com.ydespreaux.shared.data.elasticsearch.scroll.ScrolledPageResult;import com.ydespreaux.shared.data.elasticsearch.scroll.SearchScrollResult;import io.searchbox.action.Action;import io.searchbox.client.JestClient;import io.searchbox.client.JestResult;import io.searchbox.client.JestResultHandler;import io.searchbox.core.*;import io.searchbox.indices.CreateIndex;import io.searchbox.indices.DeleteIndex;import io.searchbox.indices.IndicesExists;import io.searchbox.indices.Refresh;import io.searchbox.indices.template.DeleteTemplate;import io.searchbox.indices.template.GetTemplate;import io.searchbox.indices.template.PutTemplate;import io.searchbox.params.Parameters;import lombok.extern.slf4j.Slf4j;import org.apache.commons.io.FilenameUtils;import org.elasticsearch.ElasticsearchException;import org.elasticsearch.common.Nullable;import org.elasticsearch.index.query.QueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.builder.SearchSourceBuilder;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.core.io.Resource;import org.springframework.util.Assert;import org.springframework.util.StringUtils;import java.io.IOException;import java.util.*;/** * Class define the Jest Elastic Search operations. */@Slf4jpublic class JestElasticsearchTemplate implements ElasticsearchOperations, ApplicationContextAware {    /**     * jest client property.     */    private final JestClient client;    /**     * {@link ElasticsearchConverter} property.     */    private final ElasticsearchConverter elasticsearchConverter;    /**     * The used {@link ApplicationContext}     */    private ApplicationContext applicationContext;    /**     * Construct an instance with the given client and elasticsearchConverter parameters.     *     * @param client                 the given client.     * @param elasticsearchConverter the given elasticsearchConverter.     */    public JestElasticsearchTemplate(final JestClient client,                                     final ElasticsearchConverter elasticsearchConverter) {        this.client = client;        this.elasticsearchConverter = elasticsearchConverter;    }    /**     * @see ElasticsearchOperations#execute(Action) method     */    @Override    public <T extends JestResult> T execute(io.searchbox.action.Action<T> action) {        try {            return client.execute(action);        } catch (IOException e) {            throw new ElasticsearchException(e);        }    }    /**     * @see ElasticsearchOperations#executeAsync(Action, JestResultHandler)  method     */    @Override    public <T extends JestResult> void executeAsync(io.searchbox.action.Action<T> action, JestResultHandler<? super T> handler) {        client.executeAsync(action, handler);    }    /**     * @see ElasticsearchOperations#getPersistentEntityFor(Class)  method     */    @Override    public <T> ElasticsearchPersistentEntity<T> getPersistentEntityFor(Class<T> clazz) {        Assert.isTrue(clazz.isAnnotationPresent(Document.class), "Unable to identify template. " + clazz.getSimpleName()                + " is not a TimeBasedDocument. Make sure the document class is annotated with @TimeBasedDocument");        return elasticsearchConverter.getRequiredPersistentEntity(clazz);    }    /**     * @see ElasticsearchOperations#createTemplate(String, String, Boolean)  method     */    @Override    public void createTemplate(String templateName, String location, Boolean createOnly) {        Resource resource = applicationContext.getResource(location);        if (!resource.exists()) {            throw new ElasticsearchException("File {} not found", location);        }        createTemplate(templateName, Collections.singletonList(resource), createOnly);    }    /**     * @see ElasticsearchOperations#createTemplate(String, String, Boolean)  method     */    @Override    public void createTemplate(String templateName, List<Resource> locations, Boolean createOnly) {        if (createOnly && templateExists(templateName)) {            return;        }        try {            String jsonTemplate = new IndexBuilder().buildTemplate(locations).string();            JestResult result = execute(new PutTemplate.Builder(templateName, jsonTemplate).build());            if (!result.isSucceeded()) {                throw new ElasticsearchException(result.getErrorMessage());            }            if (log.isInfoEnabled()) {                log.info("New template {} added : {}", templateName, jsonTemplate);            }        } catch (IOException e) {            throw new ElasticsearchException(e);        }    }    /**     * @see ElasticsearchOperations#templateExists(String)  method     */    @Override    public boolean templateExists(String templateName) {        return execute(new GetTemplate.Builder(templateName).build()).isSucceeded();    }    /**     * @see ElasticsearchOperations#deleteTemplate(String)  method     */    @Override    public void deleteTemplate(String templateName) {        if (templateExists(templateName)) {            JestResult response = execute(new DeleteTemplate.Builder(templateName).build());            if (!response.isSucceeded()) {                throw new ElasticsearchException(response.getErrorMessage());            } else if (log.isInfoEnabled()) {                log.info("Deleted template {}", templateName);            }        }    }    /**     * @see ElasticsearchOperations#deleteIndexByName(String)   method     */    @Override    public void deleteIndexByName(String indexName) {        Objects.requireNonNull(indexName);        if (indexExists(indexName)) {            JestResult response = execute(new DeleteIndex.Builder(indexName).build());            if (!response.isSucceeded()) {                throw new ElasticsearchException(response.getErrorMessage());            } else if (log.isInfoEnabled()) {                log.info("Deleted index {}", indexName);            }        }    }    /**     * @see ElasticsearchOperations#deleteIndexByAlias(String)    method     */    @Override    public void deleteIndexByAlias(String aliasName) {        Objects.requireNonNull(aliasName);        JestResult response = execute(new GetAlias.Builder(aliasName).build());        if (response.isSucceeded()) {            response.getJsonObject().entrySet().forEach(entry -> deleteIndexByName(entry.getKey()));        } else if (log.isWarnEnabled()) {            log.warn("Alias {} not found", aliasName);        }    }    /**     * Check if Index Exist     *     * @param indexName     * @return true if index exist     */    @Override    public boolean indexExists(String indexName) {        Objects.requireNonNull(indexName);        JestResult response = execute(new IndicesExists.Builder(indexName).build());        return response.isSucceeded();    }    @Override    public boolean createIndex(String indexName) {        Objects.requireNonNull(indexName);        JestResult response = execute(new CreateIndex.Builder(indexName).build());        return response.isSucceeded();    }    /**     * @param indexName     * @param indexPath     * @return     */    @Override    public boolean createIndexWithSettingsAndMapping(String indexName, String indexPath) {        final String[] profiles = this.applicationContext.getEnvironment().getActiveProfiles();        List<Resource> locations = new ArrayList<>(profiles.length + 1);        Resource resource = this.applicationContext.getResource(indexPath);        if (resource.exists()) {            locations.add(resource);        } else if (log.isWarnEnabled()) {            log.warn("Resource {} not found", indexPath);        }        String extension = FilenameUtils.getExtension(indexPath);        boolean hasExtension = StringUtils.hasLength(extension);        String prefix = indexPath.substring(0, indexPath.length() - (hasExtension ? extension.length() + 1 : 0));        for (String profile : profiles) {            String profilPath = prefix + "-" + profile + (hasExtension ? "." + extension : "");            Resource profilResource = this.applicationContext.getResource(profilPath);            if (profilResource.exists()) {                locations.add(profilResource);            }        }        try {            String jsonIndex = new IndexBuilder().buildTemplate(locations).string();            JestResult result = execute(new CreateIndex.Builder(indexName).payload(jsonIndex).build());            if (log.isInfoEnabled() && result.isSucceeded()) {                log.info("New index {} added : {}", indexName, jsonIndex);            }            return result.isSucceeded();        }catch(IOException e) {            throw new ElasticsearchException(e);        }    }    /**     * @see ElasticsearchOperations#index(Object, Class)     method     */    @Override    public <T> T index(T entity, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        Index request = createIndexRequest(entity, clazz);        DocumentResult response = execute(request);        if (!response.isSucceeded()) {            throw new ElasticsearchException(response.getErrorMessage());        }        persistentEntity.setPersistentEntityId(entity, response.getId());        persistentEntity.setPersistentEntityVersion(entity, response.getVersion().intValue());        return entity;    }    /**     * @see ElasticsearchOperations#bulkIndex(List, Class) method     */    @Override    public <T> List<T> bulkIndex(List<T> entities, Class<T> clazz) {        if (entities.isEmpty())            return entities;        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        Bulk.Builder builder = new Bulk.Builder();        entities.forEach(entity -> builder.addAction(createIndexRequest(entity, clazz)));        BulkResult response = execute(builder.build());        if (!response.isSucceeded()) {            Map<String, String> failedDocuments = new HashMap<>();            for (BulkResult.BulkResultItem item : response.getFailedItems()) {                failedDocuments.put(item.id, item.error);            }            throw new ElasticsearchException(                    "Bulk indexing has failures. Use ElasticsearchException.getFailedDocuments() for detailed messages ["                            + failedDocuments + "]",                    failedDocuments);        }        List<BulkResult.BulkResultItem> items = response.getItems();        for (int i = 0; i < entities.size(); i++) {            persistentEntity.setPersistentEntityId(entities.get(i), items.get(i).id);            persistentEntity.setPersistentEntityVersion(entities.get(i), items.get(i).version);        }        return entities;    }    @Override    public List<?> bulkIndex(List<?> entities) {        if (entities.isEmpty())            return entities;        Bulk.Builder builder = new Bulk.Builder();        entities.forEach(entity -> {            builder.addAction(createIndexRequest(entity, entity.getClass()));        });        BulkResult response = execute(builder.build());        checkBulkResultError(response);        List<BulkResult.BulkResultItem> items = response.getItems();        for (int i = 0; i < entities.size(); i++) {            Object entity = entities.get(i);            ElasticsearchPersistentEntity persistentEntity = getPersistentEntityFor(entity.getClass());            persistentEntity.setPersistentEntityId(entity, items.get(i).id);            persistentEntity.setPersistentEntityVersion(entity, items.get(i).version);        }        return entities;    }    /**     *     * @param response     */    private void checkBulkResultError(BulkResult response) {        if (!response.isSucceeded()) {            Map<String, String> failedDocuments = new HashMap<>();            for (BulkResult.BulkResultItem item : response.getFailedItems()) {                failedDocuments.put(item.id, item.error);            }            throw new ElasticsearchException(                    "Bulk indexing has failures. Use ElasticsearchException.getFailedDocuments() for detailed messages ["                            + failedDocuments + "]",                    failedDocuments);        }    }    /**     * @param source     * @return     */    private <T> Index createIndexRequest(T source, Class<?> clazz) {        Objects.requireNonNull(source);        ElasticsearchPersistentEntity<T> persistentEntity = (ElasticsearchPersistentEntity<T>) getPersistentEntityFor(clazz);        return new Index.Builder(source).index(persistentEntity.getIndex(source)).type(persistentEntity.getType()).build();    }    /**     * @see ElasticsearchOperations#findById(Class, String)  method     */    @Override    public <T> T findById(Class<T> clazz, String documentId) {        Objects.requireNonNull(documentId, "documentId parameter canno't be null !");        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        if (persistentEntity.isIndexTimeBased()) {            SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder()                    .query(QueryBuilders.termQuery("_id", documentId))                    .version(true)                    .size(1);            Search.Builder builder = new Search.Builder(searchSourceBuilder.toString()).addIndex(persistentEntity.getAliasOrIndexName()).addType(persistentEntity.getType());            SearchResult response = execute(builder.build());            if (!response.isSucceeded()) {                throw new ElasticsearchException(response.getErrorMessage());            }            if (response.getTotal() > 0) {                SearchResult.Hit<T, Void> hit = response.getFirstHit(clazz);                return hit.source;            }        }else {            Get.Builder builder = new Get.Builder(persistentEntity.getAliasOrIndexName(), documentId).type(persistentEntity.getType());            DocumentResult response = execute(builder.build());            if (response.getJsonObject().has("found")){                boolean found = response.getJsonObject().get("found").getAsBoolean();                return found ? response.getSourceAsObject(clazz) : null;            }            if (!response.isSucceeded()) {                throw new ElasticsearchException(response.getErrorMessage());            }        }        return null;    }    /**     * @see ElasticsearchOperations#prepareSearch(QueryBuilder, Class)  method     */    @Override    public <T> Search.Builder prepareSearch(QueryBuilder query, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        return new Search.Builder(new SearchSourceBuilder()                .query(query)                .version(true)                .toString())                .addIndex(persistentEntity.getAliasOrIndexName())                .addType(persistentEntity.getType());    }    /**     * @see ElasticsearchOperations#search(Search, Class)  method     */    @Override    public <T> List<T> search(Search search, Class<T> clazz) {        final List<T> entities = new ArrayList<>();        SearchResult response = this.execute(search);        if (!response.isSucceeded()) {            throw new ElasticsearchException(response.getErrorMessage());        }        response.getHits(clazz).forEach(hit -> entities.add(hit.source));        return entities;    }    /**     * @see ElasticsearchOperations#startScroll(long, int, Search.Builder, Class)  method     */    @Override    public <T> ScrolledPage<T> startScroll(long scrollTimeInMinutes, int size, Search.Builder builder, Class<T> clazz) {        //        builder                .setParameter(Parameters.SCROLL, scrollTimeInMinutes + "m")                .setParameter(Parameters.SIZE, size);        //        SearchResult response = this.execute(builder.build());        if (!response.isSucceeded()) {            throw new ElasticsearchException(response.getErrorMessage());        }        return ScrolledPageResult.of(new SearchScrollResult(response), clazz);    }    /**     * @see ElasticsearchOperations#continueScroll(String, long, Class)   method     */    @Override    public <T> ScrolledPage<T> continueScroll(@Nullable String scrollId, long scrollTimeInMinutes, Class<T> clazz) {        SearchScroll scroll = new SearchScroll.Builder(scrollId, scrollTimeInMinutes + "m").build();        JestResult response = this.execute(scroll);        if (!response.isSucceeded()) {            throw new ElasticsearchException(response.getErrorMessage());        }        return ScrolledPageResult.of(new SearchScrollResult(response), clazz);    }    /**     * @see ElasticsearchOperations#clearScroll(String)  method     */    @Override    public void clearScroll(String scrollId) {        JestResult response = this.execute(new ClearScroll.Builder().addScrollId(scrollId).build());        if (!response.isSucceeded()) {            throw new ElasticsearchException(response.getErrorMessage());        }    }    /**     * @see ElasticsearchOperations#deleteAll(Class)  method     */    @Override    public <T> void deleteAll(Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        if (persistentEntity.isIndexTimeBased()) {            JestResult response = execute(new GetAlias.Builder(persistentEntity.getAliasOrIndexName()).build());            if (response.isSucceeded()) {                response.getJsonObject().entrySet().forEach(entry -> deleteIndexByName(entry.getKey()));            } else if (log.isWarnEnabled()) {                log.warn("Alias {} not found", persistentEntity.getAliasOrIndexName());            }        }else{            deleteByQuery(QueryBuilders.matchAllQuery(), clazz);        }    }    /**     * @see ElasticsearchOperations#deleteAll(List, Class)  method     */    @Override    public <T> void deleteAll(List<T> entities, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        Set<String> ids = new HashSet<>();        entities.forEach(entity -> persistentEntity.getPersistentEntityId(entity).ifPresent(ids::add));        if (!ids.isEmpty()) {            deleteByQuery(QueryBuilders.termsQuery("_id", ids), clazz);        }    }    /**     * @see ElasticsearchOperations#delete(Object, Class)   method     */    @Override    public <T> void delete(T entity, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        persistentEntity.getPersistentEntityId(entity).ifPresent(documentId -> this.deleteById(documentId, clazz));    }    /**     * @see ElasticsearchOperations#deleteById(String, Class)   method     */    @Override    public <T> void deleteById(String documentId, Class<T> clazz) {        Assert.notNull(documentId, "documentId must not be null!");        deleteByQuery(QueryBuilders.termQuery("_id", documentId), clazz);    }    /**     * @param query     */    private <T> void deleteByQuery(QueryBuilder query, Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder().query(query);        DeleteByQuery.Builder builder = new DeleteByQuery.Builder(searchSourceBuilder.toString())                .addIndex(persistentEntity.getAliasOrIndexName())                .addType(persistentEntity.getType());        JestResult response = execute(builder.build());        if (!response.isSucceeded()) {            throw new ElasticsearchException(response.getErrorMessage());        }    }    /**     * @see ElasticsearchOperations#refresh(Class)  method     */    @Override    public <T> void refresh(Class<T> clazz) {        ElasticsearchPersistentEntity<T> persistentEntity = getPersistentEntityFor(clazz);        Refresh.Builder builder = new Refresh.Builder().addIndex(persistentEntity.getAliasOrIndexName());        JestResult response = execute(builder.build());        if (!response.isSucceeded()) {            throw new ElasticsearchException(response.getErrorMessage());        }    }    /**     * @see ApplicationContextAware#setApplicationContext(ApplicationContext)  method     */    @Override    public void setApplicationContext(ApplicationContext applicationContext) {        this.applicationContext = applicationContext;    }}